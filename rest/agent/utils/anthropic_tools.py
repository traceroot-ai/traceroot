import re
from inspect import Parameter, signature
from typing import Any, Callable, Mapping

from docstring_parser import parse
from pydantic import create_model
from pydantic.fields import FieldInfo


def to_pascal(snake: str) -> str:
    """Convert a snake_case string to PascalCase.

    Args:
        snake (str): The snake_case string to be converted.

    Returns:
        str: The converted PascalCase string.
    """
    # Check if the string is already in PascalCase
    if re.match(r'^[A-Z][a-zA-Z0-9]*([A-Z][a-zA-Z0-9]*)*$', snake):
        return snake
    # Remove leading and trailing underscores
    snake = snake.strip('_')
    # Replace multiple underscores with a single one
    snake = re.sub('_+', '_', snake)
    # Convert to PascalCase
    return re.sub(
        '_([0-9A-Za-z])',
        lambda m: m.group(1).upper(),
        snake.title(),
    )


def get_anthropic_tool_schema(func: Callable) -> dict[str, Any]:
    r"""Generates an Anthropic JSON schema from a given Python function.

    This function creates a schema compatible with Anthropic's API
    specifications, based on the provided Python function. It processes the
    function'sparameters, types, and docstrings, and constructs a schema
    accordingly.

    Note:
        - Each parameter in `func` must have a type annotation; otherwise, it's
          treated as 'Any'.
        - Variable arguments (*args) and keyword arguments (**kwargs) are not
          supported and will be ignored.
        - A functional description including a brief and detailed explanation
          should be provided in the docstring of `func`.
        - All parameters of `func` must be described in its docstring.
        - Supported docstring styles: ReST, Google, Numpydoc, and Epydoc.

    Args:
        func (Callable): The Python function to be converted into an Anthropic
                         JSON schema.

    Returns:
        dict[str, Any]: A dictionary representing the Anthropic tool schema of
                        the provided function.
    """
    params: Mapping[str, Parameter] = signature(func).parameters
    fields: dict[str, tuple[type, FieldInfo]] = {}
    for param_name, p in params.items():
        param_type = p.annotation
        param_default = p.default
        param_kind = p.kind
        param_annotation = p.annotation
        # Variable parameters are not supported
        if (param_kind == Parameter.VAR_POSITIONAL
                or param_kind == Parameter.VAR_KEYWORD):
            continue
        # If the parameter type is not specified, it defaults to typing.Any
        if param_annotation is Parameter.empty:
            param_type = Any
        # Check if the parameter has a default value
        if param_default is Parameter.empty:
            fields[param_name] = (param_type, FieldInfo())
        else:
            fields[param_name] = (param_type, FieldInfo(default=param_default))

    # Applying `create_model()` directly will result in a mypy error,
    # create an alias to avoid this.
    def _create_mol(name, field):
        return create_model(name, **field)

    model = _create_mol(to_pascal(func.__name__), fields)
    input_schema_dict = model.model_json_schema()

    # The `"title"` is generated by `model.model_json_schema()`
    # but is useless for the tool schema, so we remove it.
    _remove_title_recursively(input_schema_dict)

    docstring = parse(func.__doc__ or "")
    for param in docstring.params:
        if (name := param.arg_name) in input_schema_dict["properties"] and (
                description := param.description):
            input_schema_dict["properties"][name]["description"] = description

    short_description = docstring.short_description or ""
    long_description = docstring.long_description or ""
    if long_description:
        func_description = f"{short_description}\n{long_description}"
    else:
        func_description = short_description

    anthropic_tool_schema = {
        "name": func.__name__,
        "description": func_description,
        "input_schema": input_schema_dict,
    }

    return anthropic_tool_schema


def _remove_title_recursively(data, parent_key=None):
    r"""Recursively removes the 'title' key from all levels of a nested
    dictionary, except when 'title' is an argument name in the schema.
    """
    if isinstance(data, dict):
        # Only remove 'title' if it's not an argument name
        if parent_key not in [
                "properties",
                "$defs",
                "items",
                "allOf",
                "oneOf",
                "anyOf",
        ]:
            data.pop("title", None)

        # Recursively process each key-value pair
        for key, value in data.items():
            _remove_title_recursively(value, parent_key=key)
    elif isinstance(data, list):
        # Recursively process each element in the list
        for item in data:
            _remove_title_recursively(item, parent_key=parent_key)
